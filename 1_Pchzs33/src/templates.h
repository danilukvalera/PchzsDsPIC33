//*****************************************************************************
// Команды препроцессора для предотвращения повторного включения содержимого файла
//*****************************************************************************
#ifndef TEMPLATES_H
#define TEMPLATES_H

//*****************************************************************************
// Подключаемые файлы
//*****************************************************************************
#include <stdint.h>
#include <stdbool.h>

//*****************************************************************************
// Макросы типа функция
//*****************************************************************************

//*****************************************************************************
/// \brief Слияние двух токенов.
///
#define CAT( X,Y ) X##_##Y

//*****************************************************************************
/// \brief Определение имени из двух частей, например CAT_NAME_X_Y(111, 22) получаем 111_22.
///
#define CAT_NAME_X_Y( X,Y ) CAT( X,Y )        

//*****************************************************************************
/// \brief Минимум.
/// \note Макрос возвращает меньшее из двух значений, указанных в параметрах a и b.
///
#define MIN( a,b ) ( ( ( a )<( b ) )?( a ):( b ) )

//*****************************************************************************
/// \brief Максимум.
/// \note Макрос возвращает большее из двух значений, указанных в параметрах a и b.
///
#define MAX( a,b ) ( ( ( a )>( b ) )?( a ):( b ) )

//*****************************************************************************
// Макроопределения для работы с битами

//*****************************************************************************
/// \brief Установить указанный бит в единицу.
///
#define SETBIT( x, y  ) ( ( x ) |= ( 1 << ( y ) ) )

//*****************************************************************************
/// \brief Установить указанный бит в ноль.
///
#define CLEARBIT( x, y ) ( ( x ) &= ( ~( 1 << ( y ) ) ) )

//*****************************************************************************
/// \brief Инвертировать указанный бит.
///
#define TOGGLEBIT( x, y ) ( ( x ) ^= ( 1 << ( y ) ) )

//*****************************************************************************
/// \brief Выделить указанный бит для проверки.
///
#define CHECKBIT( x, y ) ( ( x ) & ( 1 << ( y ) ) )

//*****************************************************************************
/// \brief Проверить бит регистра.
/// \param reg       - имя регистра;
/// \param numberBit - номер бита в регистре.
/// \return Возвращает true, если бит регистра установлен в 1.
/// \note Преобразование в \a REGbits.REGnumberBit != 0.
/// \note Позволяет контролировать наличие бита в регистре на этапе компиляции.
///
#define CHECKBIT_REGISTER( reg, numberBit ) reg##bits.reg##numberBit != 0

//*****************************************************************************
/// \brief Установить бит регистра.
/// \param reg       - имя регистра;
/// \param numberBit - номер бита в регистре;
/// \param data      - значение, в которое устанавливается бит регистр.
/// \note Преобразование в \a REGbits.REGnumberBit = data.
/// \note Позволяет контролировать наличие бита в регистре на этапе компиляции.
///
#define SETBIT_REGISTER( reg, numberBit, data ) reg##bits.reg##numberBit = data

//*****************************************************************************
// Определение типов данных
//*****************************************************************************

//*****************************************************************************
/// \brief Определение констант. 
///
typedef enum _ON_OFF
{
    OFF = false,        ///< состояние выключено
    ON  = true          ///< состояние включено
} ON_OFF;

//*****************************************************************************
/// \brief Битовая структура для uint8_t.
///
typedef struct
{
    uint8_t b0 :1;        ///< 0 бит.
    uint8_t b1 :1;        ///< 1 бит.
    uint8_t b2 :1;        ///< 2 бит.
    uint8_t b3 :1;        ///< 3 бит.
    uint8_t b4 :1;        ///< 4 бит.
    uint8_t b5 :1;        ///< 5 бит.
    uint8_t b6 :1;        ///< 6 бит.
    uint8_t b7 :1;        ///< 7 бит.
} StrBitUint8;

//*****************************************************************************
/// \brief Объединение битовой структуры для uint8_t.
///
typedef union
{
    StrBitUint8 str;        ///< Представление данных в формате структуры StrBitUint8.
    uint8_t     data;       ///< Представление данных в формате uint8_t.
} UniBitUint8;

//*****************************************************************************
/// \brief Битовая структура для uint16_t.
///
typedef struct
{
    uint16_t b0  :1;        ///< 0 бит.
    uint16_t b1  :1;        ///< 1 бит.
    uint16_t b2  :1;        ///< 2 бит.
    uint16_t b3  :1;        ///< 3 бит.
    uint16_t b4  :1;        ///< 4 бит.
    uint16_t b5  :1;        ///< 5 бит.
    uint16_t b6  :1;        ///< 6 бит.
    uint16_t b7  :1;        ///< 7 бит.
    uint16_t b8  :1;        ///< 8 бит.
    uint16_t b9  :1;        ///< 9 бит.
    uint16_t b10 :1;        ///< 10 бит.
    uint16_t b11 :1;        ///< 11 бит.
    uint16_t b12 :1;        ///< 12 бит.
    uint16_t b13 :1;        ///< 13 бит.
    uint16_t b14 :1;        ///< 14 бит.
    uint16_t b15 :1;        ///< 15 бит.
} StrBitUint16;

//*****************************************************************************
/// \brief Объединение битовой структуры для uint16_t.
///
typedef union
{
    StrBitUint16 str;        ///< Представление данных в формате структуры StrBitUint16.
    uint16_t     data;       ///< Представление данных в формате uint16_t.
} UniBitUint16;

//*****************************************************************************
/// \brief Направление потока DMA.
///
/*
typedef enum
{
    eDMA_writeRAM = 0,        ///< запись в ОЗУ из устройства
    eDMA_readRAM  = 1         ///< чтение из ОЗУ в устройство
} DMA_direct;
*/
#endif

//*****************************************************************************
